// flow-typed signature: 2fcfd65361ef66e66cf98757ca95623a
// flow-typed version: <<STUB>>/prosemirror-state_v1.1.0/flow_v0.66.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'prosemirror-transform'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module "prosemirror-transform" {
  import type {
    Node,
    Mark,
    NodeSpec,
    MarkSpec,
    NodeType,
    MarkType,
    Schema,
    Fragment,
    Slice,
    Attributes,
    NodeRange,
    ContentMatch
  } from "prosemirror-model"

  // declare export type Config = {
  //   schema?: Schema,
  //   plugins?: Plugin[],
  //   selection?: Selection,
  //   doc?: Node
  // }

  declare export type JSON<a> = a

  // declare type PluginFields = { [string]: Plugin<*> }

  // declare export class EditorState {
  //   doc: Node;
  //   selection: Selection;
  //   storedMarks: Mark[];
  //   schema: Schema;
  //   plugins: Plugin[];
  //   apply(Transaction): Transaction;
  //   applyTransaction(
  //     Transaction
  //   ): { state: EditorState, transaction: Transaction };
  //   tr: Transaction;
  //   reconfigure(Config): EditorState;
  //   toJSON(?PluginFields): JSON<EditorState>;

  //   static create(Config): EditorState;
  //   static fromJSON(Config, JSON<EditorState>, ?PluginFields): EditorState;
  // }

  // declare export class Selection {
  //   ranges: SelectionRange[];
  //   $anchor: ResolvedPos;
  // }

  // declare export class SelectionRange {
  //   $from: ResolvedPos;
  //   $to: ResolvedPos;
  //   constructor($from: ResolvedPos, $to: ResolvedPos): void;
  // }

  declare type NodeMarkup = {
    type: NodeType,
    attrs?: Attributes
  }

  declare export class Step {
    apply(doc: Node): StepResult;
    getMap(): StepMap;
    invert(doc: Node): Step;
    map(mapping: Mappable): ?Step;
    merge(other: Step): ?Step;
    toJSON(): JSON<Step>;
    static fromJSON(schema: Schema, json: JSON<Step>): Step;
    static jsonID(id: string, stepClass: Class<Step>): void;
  }

  declare export class StepResult {
    doc: ?Node;
    failed: ?string;
    static ok(doc: Node): StepResult;
    static fail(message: string): StepResult;
    static fromReplace(
      doc: Node,
      from: number,
      to: number,
      slice: Slice
    ): StepResult;
  }

  declare export class ReplaceStep extends Step {
    constructor(
      from: number,
      to: number,
      slice: Slice,
      structure?: boolean
    ): void;
  }

  declare export class ReplaceAroundStep extends Step {
    constructor(
      from: number,
      to: number,
      gapFrom: number,
      gapTo: number,
      slice: Slice,
      insert: number,
      structure?: boolean
    ): void;
  }

  declare export class AddMarkStep extends Step {
    constructor(from: number, to: number, mark: Mark): void;
  }

  declare export class RemoveMarkStep extends Step {
    (from: number, to: number, mark: Mark): void;
  }

  declare export interface Mappable {
    map(pos: number, assoc?: number): number;
    mapResult(pos: number, assoc?: number): MapResult;
  }

  declare export class MapResult {
    pos: number;
    deleted: boolean;
  }

  declare export class StepMap {
    constructor(ranges: [number]): void;
    forEach(
      f: (
        oldStart: number,
        oldEnd: number,
        newStart: number,
        newEnd: number
      ) => void
    ): void;
    invert(): StepMap;
    map(pos: number, assoc?: number): number;
    mapResult(pos: number, assoc?: number): MapResult;

    static offset(n: number): StepMap;
  }

  declare export class Mapping {
    constructor(maps?: [StepMap]): void;
    maps: [StepMap];
    from: number;
    to: number;
    slice(from?: number, to?: number): Mapping;
    appendMap(map: StepMap, mirrors?: number): void;
    appendMapping(mapping: Mapping): void;
    appendMappingInverted(mapping: Mapping): void;

    map(pos: number, assoc?: number): number;
    mapResult(pos: number, assoc?: number): MapResult;
  }

  declare export class Transform {
    doc: Node;
    steps: Step[];
    docs: Node[];
    mapping: Mapping;
    before: Node;
    docChanged: boolean;

    constructor(doc: Node): void;
    step(Step): self;
    maybeStep(Step): StepResult;
    addMark(from: number, to: number, mark: Mark): self;
    removeMark(from: number, to: number, mark?: null | Mark | MarkType): self;
    clearIncompatible(
      pos: number,
      parentType: NodeType,
      match?: ContentMatch
    ): self;
    replace(from: number, to?: number, slice?: Slice): self;
    replaceWith(
      from: number,
      to: number,
      content: Fragment | Node | Node[]
    ): self;
    delete(from: number, to: number): self;
    insert(pos: number, content: Fragment | Node | Node[]): self;
    replaceRange(from: number, to: number, slice: Slice): self;
    replaceRangeWith(from: number, to: number, node: Node): self;
    deleteRange(from: number, to: number): self;
    lift(range: NodeRange, target: number): self;
    wrap(range: NodeRange, wrappers: NodeMarkup[]): self;
    setBlockType(from: number, to?: number, NodeType, Attributes): self;
    setNodeMarkup(pos: number, type: ?NodeType, ?Attributes, ?(Mark[])): self;
    split(pos: number, depth?: number, ?(NodeMarkup[])): self;
    join(pos: number, depth?: number): self;
    replaceStep(doc: Node, from: number, to?: ?number, slice?: Slice): Step;
    liftTarget(range: NodeRange): ?number;
    findWrapping(
      range: NodeRange,
      nodeType: NodeType,
      attrs?: Attributes
    ): NodeMarkup[];
    canSplit(doc: Node, pos: number, depth?: number, ?(NodeMarkup[])): boolean;
    canJoin(doc: Node, pos: number): boolean;
    joinPoint(doc: Node, pos: number, dir?: number): ?number;
    insertPoint(doc: Node, pos: number, nodeType: NodeType): ?number;
  }
}
