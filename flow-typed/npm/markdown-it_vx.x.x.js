// flow-typed signature: dd38702f035ffdf00d5a63cdc5b85f4b
// flow-typed version: <<STUB>>/markdown-it_v8.4.1/flow_v0.66.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'markdown-it'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module "markdown-it" {
  declare export interface Plugin<config> {
    (MarkdownIt, config): void;
  }

  declare export class ParserBlock {
    constructor(): void;
    ruler: Ruler<StateBlock>;
    parse(str: string, md: MarkdownIt, env: Env, outTokens: Token[]): void;
  }

  declare export class ParserInline {
    ruler: Ruler<StateInline>;
    ruler2: Ruler<StateInline>;
    constructor(): void;
    parse(str: string, md: MarkdownIt, env: Env, outTokens: Token[]): void;
  }

  declare export class Renderer {
    constructor(Token[], Options, Env): void;
    renderAttrs(Token): string;
    renderInline(Token[], Options, Env): string;
    renderInlineAsText(Token[], Options, Env): string;
    renderToken(Token[], index: number, Options): string;
    rules: { [string]: (Token[], number, Options, Env) => string };
  }

  declare export class Core {
    ruler: Ruler<StateCore>;
    process(StateCore): void;
  }

  declare export interface StateCore {
    src: string;
    env: Env;
    tokens: Token[];
    inlineMode: boolean;
    md: MarkdownIt;
    Token: Class<Token>;
  }

  declare export interface StateInline {
    tokens: Token[];
    env: Env;
    pos: number;
    posMax: number;
    level: number;
    md: MarkdownIt;
    pending: string;
    pendingLevel: number;
    cache: { start?: number, end?: number };
    delimiters: string[];
    inlineMode?: boolean;

    pushPending(): Token;
    push(type: string, tag: string, nesting: number): Token;
    scanDelims(
      start: number,
      boolean
    ): {
      can_open: boolean,
      can_close: boolean,
      length: number
    };

    Token: Class<Token>;
  }

  declare export interface StateBlock {
    tokens: Token[];
    env: Env;
    src: string;
    bMarks: number[];
    eMarks: number[];
    tShift: number[];
    sCount: number[];
    bsCount: number[];
    blkIndent: number;

    line: number;
    lineMax: number;
    tight: boolean;
    ddIndent: number;

    parentType: "blockquote" | "list" | "root" | "paragraph" | "reference";
    level: number;
    result: string;

    level: number;
    md: MarkdownIt;
    push(type: string, tag: string, nesting: number): Token;
    isEmpty(line: number): boolean;
    skipEmptyLines(from: number): number;
    skipSpaces(pos: number): number;
    skipSpacesBack(pos: number, min: number): number;
    skipChars(pos: number, code: number): number;
    skipCharsBack(pos: number, code: number, min: number): number;
    getLines(
      begin: number,
      end: number,
      indent: number,
      keepLastLF: boolean
    ): string;

    Token: Class<Token>;
  }

  declare type Rule<state> = (
    state,
    startLine: number,
    endLine: number,
    silent: boolean
  ) => ?boolean

  declare interface Ruler<state> {
    after(
      afterName: string,
      ruleName: string,
      Rule<state>,
      ?{ alt: string[] }
    ): void;
    at(name: string, (state) => void, ?{ alt: string[] }): void;
    before(
      beforeName: string,
      ruleName: string,
      Rule<state>,
      ?{ alt: string[] }
    ): void;
    disable(string | string[], ?boolean): string[];
    enable(string | string[], ?boolean): string[];
    enableOnly(string | string[], ?boolean): string[];
    getRules(chainName: string): string[];
    push(ruleName: string, (state) => void, ?{ alt: string[] }): void;
  }

  declare export class Token {
    constructor(type: string, tag: string, nesting: number): void;
    attrIndex(name: string): number;
    attrJoin(string: string, value: string): void;
    attrPush(name: string, value: string): void;
    attrSet(name: string, value: string): void;
    attrGet(name: string): ?string;
    attrs: Array<[string, string]>;
    block: boolean;
    children: Token[];
    content: string;
    hidden: boolean;
    info: string;
    level: number;
    map: [number, number];
    markup: string;
    meta: { [string]: mixed };
    nesting: -1 | 0 | 1;
    tag: string;
    type: string;
  }

  declare export type Env = { [string]: mixed }

  declare export type Options = {
    html?: boolean,
    xhtmlOut?: boolean,
    breaks?: boolean,
    langPrefix?: string,
    linkify?: boolean,
    typographer?: boolean,
    quotes?: string | string[],
    highlight?: (code: string, lang: string) => string
  }

  declare export default class MarkdownIt {
    constructor(): MarkdownIt;
    constructor(preset: string): MarkdownIt;
    constructor(Options): MarkdownIt;
    constructor(preset: string, Options): MarkdownIt;
    configure(preset: string): void;
    disable(string | string[], ?boolean): void;
    enable(string | string[], ?boolean): void;
    parse(source: string, env: Env): Token[];
    parseInline(source: string, env: Env): Token[];
    render(src: string, ?Object): string;
    renderInline(src: string, ?Object): string;
    set({ [string]: mixed }): void;
    use<config>(Plugin<config>, config): void;
    static normalizeLink(string): string;
    static normalizeLinkText(string): string;
    static validateLink(string): boolean;

    block: ParserBlock;
    core: Core;
    helpers: {
      parseLinkLabel(
        StateInline,
        start: number,
        disableNested: boolean
      ): number,
      parseLinkDestination(
        str: string,
        pos: number,
        max: number
      ): {
        ok: boolean,
        str: string,
        lines: number,
        pos: number
      },
      parseLinkTitle(
        str: string,
        pos: number,
        max: number
      ): {
        ok: boolean,
        str: string,
        lines: number,
        pos: number
      }
    };
    inline: ParserInline;
    renderer: Renderer;
    linkify: StateCore => void;
  }
}
